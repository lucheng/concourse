// matchDll.cpp : 定义 DLL 应用程序的导出函数。
//
#include "stdafx.h"

int sum(int a,int b)
{
	return a+b;
}

int matchAndAlign(const char * dir, double rate) 
{
	char** files=new char*[100];
	int size=0;
	filehelp::getFileListInOneDir(dir,"temp",size, files);
	string templateFile(dir);
	templateFile+="template/";
	int templateNum=0;
	ElementList  *roots1=xmlhelp::getRootList(files,size);
	ElementList  *roots2=new ElementList ();				
	int *nums=new int[size];	

	int t=0;
	while (size > 0) {
		size--;
		templateNum++;
		int total = 1;
		cout<<"now produce the template: "<<templateNum<<endl;
		TiXmlElement *root = roots1->front();
		roots1->pop_front();
		bool flag1 = false;
		bool flag2 = false;		
		while (roots1->size() > 0) {
			cout<<t++<<endl;
			TiXmlElement* root2 = roots1->front();
			roots1->pop_front();
			ElementList * nodes1 = new ElementList ();
			ElementList * nodes2 = new ElementList ();
			int w = STM(root, root2, nodes1, nodes2);						
			int m = xmlhelp::getElementCount(root2);
			if ((double) w / m >= 0.9) {
				flag1 = true;
				total++;
				size--;
				align(root, root2, nodes1, nodes2);				
				int n = xmlhelp::getNodeCount(root);
				cout<<"Clustered!!! template's current nodes is: "<<n<<" the aligned html's nodes is: "<<m<<" match nodes is:"<<w<<" similarity is: "<<(double) w / m<<endl;
			} else {
				roots2->push_back(root2);
				flag2 = true;
			}
			if (roots1->size() == 0 && flag1 && flag2) {
				xmlhelp::move(roots1, roots2);
				flag1 = false;
				flag2 = false;
			}
			delete nodes1;
			delete nodes2;			
		}
		if (flag2) {
			xmlhelp::move(roots1, roots2);			
		}
		nums[templateNum - 1] = total;		
		xmlhelp::reduceElement(root, total*800/1000);
		string outFile=templateFile+utils::numToString(templateNum)+"-"+utils::numToString(total)+".html";							
		root->GetDocument()->SaveFile(outFile.c_str());		;
	}
}

int STM(TiXmlElement *element1, TiXmlElement *element2,ElementList  *matchNodes1, ElementList  *matchNodes2) 
{	
	if (strcmp(element1->Value(),element2->Value())!=0 
		|| (NULL!=element1->Attribute("title") &&  NULL!=element2->Attribute("title") && strcmp(element1->Attribute("title"),element2->Attribute("title"))!=0)
		|| (NULL!=element1->Attribute("title") &&  NULL==element2->Attribute("title")) 
		|| (NULL==element1->Attribute("title") &&  NULL!=element2->Attribute("title"))){
			return 0;
	}	
	int n=element1->ChildElementCount();
	int m=element2->ChildElementCount();

	TiXmlElement *child1=element1->FirstChildElement();
	TiXmlElement *child2=element2->FirstChildElement();	

	ElementList  **u=new ElementList  *[n+1];
	ElementList  **v=new ElementList  *[n+1];
	int** c=new int *[n+1];
	int** b=new int *[n+1];
	for (int i=0; i<n+1; i++) {
		c[i] = new int[m+1];
		b[i] = new int[m+1];
		u[i] = new ElementList [m+1];
		v[i] = new ElementList [m+1];		
	}

	for (int j=0; j<m+1; j++) {
		c[0][j]=0;
		b[0][j]=0;
	}

	for (int i=0; i<n+1; i++) {
		c[i][0]=0;
		b[i][0]=0;
	}

	int i=0;
	TiXmlElement *p=child2;
	while (NULL!=child1) {	
		i++;
		child2=p;
		int j=0;
		while (NULL!=child2) {
			j++;
			int w=STM(child1,child2,&u[i][j],&v[i][j]);
			b[i][j]=0;
			c[i][j]=c[i-1][j-1]+w;
			if (c[i][j-1]>c[i][j]) {
				c[i][j]=c[i][j-1];
				b[i][j]=1;
			}
			if (c[i-1][j]>c[i][j]) {
				c[i][j]=c[i-1][j];
				b[i][j]=2;
			}
			child2=child2->NextSiblingElement();
		}
		child1=child1->NextSiblingElement();
	}	

	i=n;
	int j=m;
	while (i>0 && j>0) {		
		if (b[i][j]==0) {			
			xmlhelp::add(matchNodes1,&u[i][j]);
			xmlhelp::add(matchNodes2,&v[i][j]);
			i--;
			j--;
		}else if(b[i][j]==1) {						
			j--;
		}else {
			i--;
		}	
	}
	matchNodes1->push_back(element1);
	matchNodes2->push_back(element2);

	int result=c[n][m]+1;

	for (i=0; i<n+1; i++) {
		delete [] b[i];
		delete [] c[i];
		delete [] u[i];
		delete [] v[i];
	}
	delete [] b;	
	delete [] c;
	delete [] u;
	delete [] v;	

	return result;	
}

void align(TiXmlElement *element1, TiXmlElement *element2, ElementList  *matchNodes1, ElementList  *matchNodes2)
{			
	int n=element1->ChildElementCount();
	int m=element2->ChildElementCount();
	if (m == 0) {
		return;
	}	

	TiXmlElement *child1=element1->FirstChildElement();
	TiXmlElement *child2=element2->FirstChildElement();	
	ElementList  *nodes1=new ElementList ();
	ElementList  *nodes2=new ElementList ();
	while (child2!=NULL) {				
		if (find(matchNodes2->begin(),matchNodes2->end(),child2)!=matchNodes2->end()) {												
			while (child1!=NULL && find(matchNodes1->begin(),matchNodes1->end(),child1)==matchNodes1->end()) {												
				child1=child1->NextSiblingElement();				
			}		

			nodes1->push_back(child1);
			nodes2->push_back(child2);
			child1=child1->NextSiblingElement();
			child2=child2->NextSiblingElement();
		}									
		TiXmlElement *o=child2;						
		while (o!=NULL && find(matchNodes2->begin(),matchNodes2->end(),o)==matchNodes2->end())
			o=o->NextSiblingElement();		
		if (o!=NULL && child1!=NULL && find(matchNodes1->begin(),matchNodes1->end(),child1)!=matchNodes1->end()) {			
			nodes1->push_back(child1);
			nodes2->push_back(o);			
			while (child2!=o) {					
				element1->InsertBeforeChild(child1,*child2);								
				child2=child2->NextSiblingElement();
			}														
			o=o->NextSiblingElement();
			child1=child1->NextSiblingElement();
		} else 
			if (o==NULL && child1==NULL) {								
				while(child2!=o) {
					element1->InsertEndChild(*child2);					
					child2=child2->NextSiblingElement();					
				}
			}		
			child2=o;			
	}	

	ElementList ::iterator i1=nodes1->begin();
	ElementList ::iterator j1=nodes2->begin();
	while( i1!=nodes1->end() && j1!=nodes2->end()) {
		TiXmlElement* node1=(TiXmlElement *) *i1;
		TiXmlElement* node2=(TiXmlElement *) *j1;	
		string numStr=node1->Attribute("my_num");							
		int num=utils::stringToNum(numStr)+1;
		node1->SetAttribute("my_num", num);		
		align(node1, node2, matchNodes1, matchNodes2);				
		i1++;
		j1++;
	}		
	delete nodes1;
	delete nodes2;
}

int matchMarked(TiXmlElement* element1, TiXmlElement* element2, ElementList* result) {
	if (strcmp(element1->Value(),element2->Value())!=0 
		|| (NULL!=element1->Attribute("title") &&  NULL!=element2->Attribute("title") && strcmp(element1->Attribute("title"),element2->Attribute("title"))!=0)
		|| (NULL!=element1->Attribute("title") &&  NULL==element2->Attribute("title")) 
		|| (NULL==element1->Attribute("title") &&  NULL!=element2->Attribute("title"))){
			return 0;
	}	
	int n=element1->ChildElementCount();
	int m=element2->ChildElementCount();

	TiXmlElement *child1=element1->FirstChildElement();
	TiXmlElement *child2=element2->FirstChildElement();	

	ElementList  **u=new ElementList  *[n+1];	
	int** c=new int *[n+1];
	int** b=new int *[n+1];
	for (int i=0; i<n+1; i++) {
		c[i] = new int[m+1];
		b[i] = new int[m+1];
		u[i] = new ElementList [m+1];		
	}

	for (int j=0; j<m+1; j++) {
		c[0][j]=0;
		b[0][j]=0;
	}

	for (int i=0; i<n+1; i++) {
		c[i][0]=0;
		b[i][0]=0;
	}

	int i=0;
	TiXmlElement *p=child2;
	while (NULL!=child1) {	
		i++;
		child2=p;
		int j=0;
		while (NULL!=child2) {
			j++;
			int w=matchMarked(child1,child2,&u[i][j]);
			b[i][j]=0;
			c[i][j]=c[i-1][j-1]+w;
			if (c[i][j-1]>c[i][j]) {
				c[i][j]=c[i][j-1];
				b[i][j]=1;
			}
			if (c[i-1][j]>c[i][j]) {
				c[i][j]=c[i-1][j];
				b[i][j]=2;
			}
			child2=child2->NextSiblingElement();
		}
		child1=child1->NextSiblingElement();
	}	

	i=n;
	int j=m;
	while (i>0 && j>0) {		
		if (b[i][j]==0) {			
			xmlhelp::add(result,&u[i][j]);			
			i--;
			j--;
		}else if(b[i][j]==1) {						
			j--;
		}else {
			i--;
		}	
	}

	int matchs=c[n][m]+1;

	for (i=0; i<n+1; i++) {
		delete [] b[i];
		delete [] c[i];
		delete [] u[i];
	}
	delete [] b;	
	delete [] c;
	delete [] u;

	if (element1->Attribute("semantic") != NULL) {
		element2->SetAttribute("semantic", element1->Attribute("semantic"));
		result->push_back(element1);
	}	

	return matchs;
}

void extract(char* templateFile,char* dir)
{
	TiXmlElement* root=xmlhelp::getRootElement(templateFile);
	int total=xmlhelp::getElementCountOfSemantic(root);
	char** files=new char*[500];
	int size=0;
	filehelp::getFileListInOneDir(dir,"temp",size, files);	
	string extractFile(dir);
	extractFile+="extraction/extraction.xml";
	TiXmlDocument* outDoc=new TiXmlDocument();
	TiXmlDeclaration* pDeclaration = new TiXmlDeclaration("1.0","GBK","");  
	outDoc->LinkEndChild(pDeclaration);
	TiXmlElement *rootElement=new TiXmlElement("items");
	outDoc->LinkEndChild(rootElement);
	for (int i=0; i<size; i++) {		
		TiXmlElement* root2=xmlhelp::getRootElement(files[i]);
		ElementList* result=new ElementList();
		matchMarked(root, root2, result);
		if ((int)result->size()>=total*8/10) {
			TiXmlElement* item=new TiXmlElement("item");
			rootElement->LinkEndChild(item);
			TiXmlElement* nameElement=new TiXmlElement("name");			
			TiXmlText* text=new TiXmlText(filehelp::getFileName(files[i]));
			nameElement->LinkEndChild(text);
			item->LinkEndChild(nameElement);
			TiXmlElement* datas=new TiXmlElement("datas");
			item->LinkEndChild(datas);
			for (int j=0; j<(int)result->size(); j++){
				TiXmlElement* data=new TiXmlElement("data");
				TiXmlElement* element=result->front();
				result->pop_front();
				TiXmlElement* title=new TiXmlElement("title");
				text=new TiXmlText(element->Attribute("semantic"));
				title->LinkEndChild(text);
				data->LinkEndChild(title);
				TiXmlElement* content=new TiXmlElement("content");				
				text=new TiXmlText(xmlhelp::getStringValue(element).c_str());
				content->LinkEndChild(text);
				data->LinkEndChild(content);
				datas->LinkEndChild(data);
			}

		}

	}
	outDoc->SaveFile(extractFile.c_str());
}